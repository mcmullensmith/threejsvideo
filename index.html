<html>
<head>
    <title>ThreeJS Video Experiment</title>

    <style>
        body {
            background-color: #cccccc;
            color: #fff;
            margin: 0px;
            overflow: hidden;
            font-family:Monospace;
            font-size:13px;
            text-align:center;
            font-weight: bold;
            text-align:center;
            background-image:url(images/space.png);
        }

        canvas{
            background: none;
        }

        video{
            width: 100%;
            height: 100%;
        }

    </style>
</head>
<body>
<div id="container">

</div>

<video id="videoA" autoplay loop webkit-playsinline style="display:none" width="720" height="810"> -->

</video>

<script src="js/three.min.js" type="text/javascript"></script>
<script src="js/motionstack-v1.0.1.js"></script>
<script src="js/libs/physi.js"></script>

<script src="js/libs/stats.min.js"></script>
<script src="js/libs/dat.gui.min.js"></script>
<script src="js/crossfade/scenes.js"></script>
<script src="js/crossfade/gui.js"></script>
<script src="js/crossfade/transition.js"></script>

<script src="js/shaders/ConvolutionShader.js"></script>
<script src="js/shaders/CopyShader.js"></script>
<script src="js/shaders/DotScreenShader.js"></script>
<script src="js/shaders/FilmShader.js"></script>
<script src="js/shaders/DigitalGlitch.js"></script>

<script src="js/postprocessing/EffectComposer.js"></script>
<script src="js/postprocessing/RenderPass.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>
<script src="js/postprocessing/BloomPass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/DotScreenPass.js"></script>
<script src="js/postprocessing/FilmPass.js"></script>
<script src="js/postprocessing/GlitchPass.js"></script>

<script src="js/postprocessing/ClearPass.js"></script>
<script src="js/postprocessing/TexturePass.js"></script>
<script src="js/postprocessing/ShaderPass.js"></script>
<script src="js/postprocessing/MaskPass.js"></script>

<script type="text/javascript">

    var container;
    var camera, sceneA, sceneC, renderer, crate;
    var videoA, videoB, textureA, textureB, material, mesh;
    var composer;
    var mouseX = 0;
    var mouseY = 0;
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;
    var clock = new THREE.Clock();

    init();
    // animate();
    render();
    function init(){
        container = document.createElement( 'div' );
        document.body.appendChild( container );
        camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );

        sceneA = new THREE.Scene();
        sceneC = new THREE.Scene();

//        torus = new THREE.Mesh( new THREE.TorusGeometry( 3, 1, 16, 32 ) );
//        sceneA.add( torus );

        box = new THREE.BoxGeometry( 1, 1, 1 );
//        sceneA.add( box );

        var light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0.5, 1, 1 ).normalize();
        sceneA.add( light );
//        sceneC.add( light );

        window.scene = sceneA;

        window.THREE = THREE;

        renderer = new THREE.WebGLRenderer( { antialias: false, alpha: true } );
        renderer.setClearColor(0xffffff, 0);
        renderer.clearAlpha = true;
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        videoA = document.getElementById( 'videoA' );
        videoA.height = 810;
        videoA.src = "textures/GearVR-Room-Loop_v2.mp4";
        videoA.setAttribute('crossorigin', 'anonymous');
        videoA.load(); // must call after setting/changing source
        videoA.play();


//        textureA = new THREE.VideoTexture( videoA );
//        textureA.minFilter = THREE.LinearFilter;
//        textureA.magFilter = THREE.LinearFilter;
//        textureA.format = THREE.RGBFormat;
//        var textureA = new THREE.TextureLoader().load( 'images/space.png' );


        textureB = new THREE.VideoTexture( videoA );
        textureB.minFilter = THREE.LinearFilter;
        textureB.magFilter = THREE.LinearFilter;
        textureB.format = THREE.RGBFormat;

//        textureB.wrapS = textureB.wrapT = THREE.RepeatWrapping;
        textureB.wrapS = textureB.wrapT = THREE.ClampToEdgeWrapping;

        var crateMaterial = new THREE.MeshLambertMaterial( { map: textureB } );
        crate = new THREE.Mesh( box, crateMaterial );
        sceneA.add(crate);



        var clearPass = new THREE.ClearPass();

        var clearMaskPass = new THREE.ClearMaskPass();

        var maskPass1 = new THREE.MaskPass( sceneA, camera );
        var maskPass2 = new THREE.MaskPass( sceneC, camera );

//        var texturePass1 = new THREE.TexturePass( textureA );
        var texturePass2 = new THREE.TexturePass( textureB );

        var outputPass = new THREE.ShaderPass( THREE.CopyShader );
        outputPass.renderToScreen = true;

        var parameters = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBFormat,
            stencilBuffer: true
        };

        var renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, parameters );

//        composer = new THREE.EffectComposer( renderer, renderTarget );
//        composer.addPass( clearPass );
//        composer.addPass( maskPass1 );
//        composer.addPass( texturePass1 );
//        composer.addPass( clearMaskPass );
//        composer.addPass( maskPass2 );
//        composer.addPass( texturePass2);
//        composer.addPass( clearMaskPass );
//        composer.addPass( outputPass );

        camera.position.z = 10;

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );

//        accelerometer();
        var motionOrientation = new MotionStack.Orientation();
        motionOrientation.start(tracking);

    }

//    function accelerometer() {
//        var accelerometer = new MotionStack.Accelerometer();
//
//        accelerometer.start(function(e) {
//            console.log(e.x, e.y, e.z);
//        });
//
//        accelerometer.stop();
//    }
    var angle, x, y, z;

    function orientation() {
//        // motion controls
//        var angle, x, y, z;
//        function tracking(e) {
//            var q = e.quaternion;
//            var factor = 1 / Math.max(1E-5, Math.sqrt(q.x * q.x + q.y * q.y + q.z * q.z));
//
//            angle = 2.0 * Math.acos(q.w) || 0;
//            x = q.x * factor;
//            y = -q.y * factor;
//            z = q.z * factor;
//        }

//        var motionOrientation = new MotionStack.Orientation();
//        motionOrientation.start(tracking);

        // animation loop
//        var $ = document.querySelectorAll.bind(document);
//        var cube = $("#cube")[0];
//        function rotateCube() {
//            cube.style.webkitTransform = "rotate3d("+ x +", "+ y +", "+ z +", "+ angle +"rad) rotateX(-90deg) translateZ(0)";
//            cube.style.transform = cube.style.webkitTransform;
//        }
//
//        var rotateThisCube = rotateCube.bind(this);
//        window.requestAnimationFrame(function loop() {
//            if(angle !== undefined) {
//                rotateThisCube();
//            }
//
//            window.requestAnimationFrame(loop);
//        });
    }

    function animate() {
        // requestAnimationFrame( animate );
        // render();
    }

    function onDocumentMouseMove(event) {
        event.preventDefault();
        mouseX = ( event.clientX - windowHalfX );
        mouseY = ( event.clientY - windowHalfY ) * 0.3;
    }

    function tracking(e) {
        var q = e.quaternion;
        var factor = 1 / Math.max(1E-5, Math.sqrt(q.x * q.x + q.y * q.y + q.z * q.z));

        angle = 2.0 * Math.acos(q.w) || 0;
        x = q.x * factor;
        y = -q.y * factor;
        z = q.z * factor;
    }

    function render() {
        var delta = clock.getDelta ();
        var time = performance.now() * 0.001;

//        camera.lookAt( sceneA.position );

//        crate.position.x = x;
//        crate.position.y =  Math.sin( time / 1.5 ) * 2;
        crate.rotation.x = x;
        crate.rotation.y = y;


        var motionOrientation = new MotionStack.Orientation();
        motionOrientation.start(tracking);


//        torus.position.x = Math.cos( time ) * 2;
//        torus.position.y = Math.sin( time / 1.5 ) * 2;
//        torus.rotation.x = time;
//        torus.rotation.y = time / 2;

//        renderer.clear();
        requestAnimationFrame( render );
//        renderer.render(scene, camera);
        renderer.render( sceneA, camera );
//        composer.render(delta);
    }
</script>
</body>
</html>
